package com.github.moribund.net.packets.account;

import com.esotericsoftware.kryonet.Connection;
import com.github.moribund.MoribundServer;
import com.github.moribund.entity.PlayableCharacter;
import com.github.moribund.entity.Player;
import com.github.moribund.game.Game;
import com.github.moribund.net.packets.IncomingPacket;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import it.unimi.dsi.fastutil.objects.ObjectList;
import javafx.util.Pair;
import lombok.val;

import java.util.concurrent.ThreadLocalRandom;

/**
 * The request sent by the client to the server that a person is making
 * an account, so it must register that request and follow instructions
 * to handle the player server-sided.
 */
public final class CreateNewPlayerRequestPacket implements IncomingPacket {
    /**
     * A private constructor to ensure the server cannot unexpectedly send this
     * request to the client.
     */
    private CreateNewPlayerRequestPacket() { }

    @Override
    public void process(Connection connection) {
        val game = MoribundServer.getInstance().getGameContainer().getAvailableGame();
        val playerId = connection.getID();
        val player = createNewPlayer(game.getGameId(), playerId, connection);

        sendNewPlayerPacket(game, player);
        game.addPlayer(playerId, player);
        sendPlayersToNewPlayer(game, player);
    }


    /**
     * Sends the {@link CreateNewPlayerPacket} to the newly made player. An important thing
     * to note is that this sends a list of players that includes the newly made player
     * him/her self.
     * @param player The newly made {@link Player}.
     */
    private void sendPlayersToNewPlayer(Game game, PlayableCharacter player) {
        // note this includes the newly made player
        ObjectList<Pair<Integer, Pair<Float, Float>>> playerTiles = new ObjectArrayList<>();
        ObjectList<Pair<Integer, Float>> playerRotations = new ObjectArrayList<>();
        game.forEachPlayer((playerId, aPlayer) -> {
            playerTiles.add(new Pair<>(playerId, new Pair<>(aPlayer.getX(), aPlayer.getY())));
            playerRotations.add(new Pair<>(playerId, aPlayer.getRotation()));
        });

        val loginPacket = new CreateNewPlayerPacket(player.getGameId(), player.getPlayerId(), playerTiles, playerRotations);
        player.getConnection().sendTCP(loginPacket);
    }

    /**
     * Sends a {@link DrawNewPlayerPacket} to all the existing {@link Player}s in the game.
     * @param newPlayer The newly made {@link Player}.
     */
    private void sendNewPlayerPacket(Game game, PlayableCharacter newPlayer) {
        val newPlayerLoginPacket = new DrawNewPlayerPacket(newPlayer.getGameId(), newPlayer.getPlayerId(), newPlayer.getX(), newPlayer.getY(), newPlayer.getRotation());
        game.forEachPlayer(player -> player.getConnection().sendTCP(newPlayerLoginPacket));
    }

    /**
     * Makes a new {@link Player} using the player ID that is generated by the
     * {@link Connection} and the {@link Connection} itself.
     * @param playerId The player ID of the newly made player.
     * @param connection The connection of the newly made player.
     * @return The newly made {@link Player}.
     */
    private Player createNewPlayer(int gameId, int playerId, Connection connection) {
        val x = ThreadLocalRandom.current().nextInt(0, 100);
        val y = ThreadLocalRandom.current().nextInt(0, 100);
        val player = new Player(gameId, playerId, x, y);
        player.setConnection(connection);
        return player;
    }
}
